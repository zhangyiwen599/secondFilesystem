# 操作系统课程设计--二级文件系统



### 一、实验目的

阅读、裁剪操作系统源代码（文件相关部分）。在深入理解操作系统文件概念和文件系统实现细节的同时，培养剖析大型软件、设计系统程序的能力。 



### 二、实验内容

1、剖析 Unix V6++源代码，深入理解其文件管理模块、高速缓存管理模块和硬盘驱动模块的设计思路和实现技术。 
2、裁剪 Unix V6++内核，用以管理二级文件系统。 

二级文件系统用一个宿主机上的大文件模拟磁盘，其管理的所有文件内容及文件系统的元数据存放在宿主机文件的相应位置。  硬盘的扇区容量是 512 个字节，因此用以模拟硬盘的大文件也以512 个字节为单位分配存储空间。举例：假设 2 级文件系统部署在文件 c:\myDisk.img 中，UNIX V6 用以读取硬盘 100#扇区的子程序是 bp = bread(0,100)；那么，在二级文件系统中，该子程序完成的功能等价于 2 个连续的系统调用 lseek(51200) 和 read(fd, &bp->b_addr, 512)。其中，fd 是 c:\myDisk.img 的打开文件描述符，bp 是缓存控制块，bp->b_addr 指向一个 512 字节的缓存块，read 系统调用结束后的一段时间之内，该缓存块用来装二级文件系统中 100#扇区的内容。 本质上说，内核用以管理（一级）文件系统的所有数据结构和内核子程序均可用来管理二级文件系统。一级文件系统与二级文件系统唯一的区别在于磁盘驱动接口。依然使用上述读100#扇区的实例。IO时，一级文件系统向硬盘发 DMA 命令，二级文件系统向一级文件系统发送 read 系统调用、由后者负责从文件 c:\myDisk.img 中读取 512个字节。 



### 三、设计思路

二级文件系统的实现主要分为三个部分：

1. 高速缓存Buffer的实现，此部分主要用于直接和磁盘进行交互，进行磁盘文件的读写。
2. 文件系统底层数据结构的实现，如Inode数据结构，打开文件结构等，以及对这些结构进行管理的函数的实现
3. 高层API调用的实现，主要实现了用于和用户直接进行交互的系统调用函数，如Fopen，Fclose等等。



由于二级文件系统是在已有的系统基础上开发的，所以这次并没有设计驱动程序，而是直接讲一级系统中的一个文件作为二级文件系统中的磁盘，而和二级文件系统中磁盘文件的读写操作直接由mmap映射完成。

二级文件的功能主要有两个可执行程序实现，一个是Initialize，一个是InterFace，其中前者主要负责的是格式化磁盘的工作，我们知道UnixV6++的磁盘格式主要分为三部分，分别是超级快，Inode快以及数据块

![1586095605124](E:\同济大学学习文件\大三\操作系统课设\secondFilesystem\assets\1586095605124.png)

其中在格式化磁盘时主要需要初始化 SuperBlock 类和一般数据块，UNIX V6++对空闲磁 盘块的管理使用成组链接法，需要在 SuperBlock 块中初始化正确的磁盘序列，将 空闲的数据块正确的分组，并为每一个分组中的第一个盘块写入索引数据。 同时格式化还需要初始化 0 号 DiskInode，它将在系统启动的时候作为指定的根目 录 Inode 被直接读入内存，必须在格式化磁盘时就将其初始化成功。

![1586095740489](E:\同济大学学习文件\大三\操作系统课设\secondFilesystem\assets\1586095740489.png)



而后者主要是与用户交互的程序，通过读入用户输入的命令来与之前已经初始化的磁盘数据进行交互。



### 四、实验环境

操作系统：Linux version 4.4.0-18362-Microsoft (Microsoft@Microsoft.com) (gcc version 5.4.0 (GCC) ) 

编译器：Thread model: posix
		gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)

### 五、详细设计

##### 4.1 Buffer 高速缓存的设计

**缓存控制块的定义**

```c++
#ifndef BUF_H
#define BUF_H

/*
 * 缓存控制块buf定义
 * 记录了相应缓存的使用情况等信息；
 * 同时兼任I/O请求块，记录该缓存
 * 相关的I/O请求和执行结果。
 */
class Buf
{
public:
	enum BufFlag	/* b_flags中标志位 */
	{
		B_WRITE = 0x1,		/* 写操作。将缓存中的信息写到硬盘上去 */
		B_READ	= 0x2,		/* 读操作。从盘读取信息到缓存中 */
		B_DONE	= 0x4,		/* I/O操作结束 */
		B_ERROR	= 0x8,		/* I/O因出错而终止 */
		B_BUSY	= 0x10,		/* 相应缓存正在使用中 */
		B_WANTED = 0x20,	/* 有进程正在等待使用该buf管理的资源，清B_BUSY标志时，要唤醒这种进程 */
		B_ASYNC	= 0x40,		/* 异步I/O，不需要等待其结束 */
		B_DELWRI = 0x80		/* 延迟写，在相应缓存要移做他用时，再将其内容写到相应块设备上 */
	};
	
public:
	unsigned int b_flags;	/* 缓存控制块标志位 */
	
	int		padding;		/* 4字节填充，使得b_forw和b_back在Buf类中与Devtab类
							 * 中的字段顺序能够一致，否则强制转换会出错。 */
	/* 缓存控制块队列勾连指针 （由于只有单进程 所以只需要一个队列）*/
	Buf*	b_forw;
	Buf*	b_back;
	// Buf*	av_forw;
	// Buf*	av_back;
	
	//short	b_dev;			/* 主、次设备号，其中高8位是主设备号，低8位是次设备号 */
	int		b_wcount;		/* 需传送的字节数 */
	unsigned char* b_addr;	/* 指向该缓存控制块所管理的缓冲区的首地址 */
	int		b_blkno;		/* 磁盘逻辑块号 */


	int		b_error;		/* I/O出错时信息 */
	int		b_resid;		/* I/O出错时尚未传送的剩余字节数 */
};

#endif

```

**缓存控制块管理类的实现**

```c++
#ifndef BUFFER_MANAGER_H
#define BUFFER_MANAGER_H

#include "Buf.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// #include "DeviceManager.h"
//由于本次是二级文件系统，所以不需要磁盘驱动

class BufferManager
{
public:
	/* static const member */
	static const int NBUF = 15;			/* 缓存控制块、缓冲区的数量 */
	static const int BUFFER_SIZE = 512;	/* 缓冲区大小。 以字节为单位 */

public:
	BufferManager();
	~BufferManager();
	
	void Initialize(char *p);					/* 缓存控制块队列的初始化。将缓存控制块中b_addr指向相应缓冲区首地址。*/
	
	//由于只有一个设备，所以删除了所有设备号

	Buf* GetBlk(int blkno);	/* 申请一块缓存，用于读写设备dev上的字符块blkno。*/
	void Brelse(Buf* bp);				/* 释放缓存控制块buf */
	void IOWait(Buf* bp);				/* 同步方式I/O，等待I/O操作结束 */
	void IODone(Buf* bp);				/* I/O操作结束善后处理 */

	Buf* Bread(int blkno);	/* 读一个磁盘块。dev为主、次设备号，blkno为目标磁盘块逻辑块号。 */
	/*Buf* Breada(int blkno, int rablkno);	/* 读一个磁盘块，带有预读方式。
														 * adev为主、次设备号。blkno为目标磁盘块逻辑块号，同步方式读blkno。
														 * rablkno为预读磁盘块逻辑块号，异步方式读rablkno。 */
	void Bwrite(Buf* bp);				/* 写一个磁盘块 */
	void Bdwrite(Buf* bp);				/* 延迟写磁盘块 */
	void Bawrite(Buf* bp);				/* 异步写磁盘块 */

	void ClrBuf(Buf* bp);				/* 清空缓冲区内容 */
	void Bflush();				/* 将dev指定设备队列中延迟写的缓存全部输出到磁盘 */
	// bool Swap(int blkno, unsigned long addr, int count, enum Buf::BufFlag flag);
										/* Swap I/O 用于进程图像在内存和盘交换区之间传输
										 * blkno: 交换区中盘块号；addr:  进程图像(传送部分)内存起始地址；
										 * count: 进行传输字节数，byte为单位；传输方向flag: 内存->交换区 or 交换区->内存。 */
	// Buf& GetSwapBuf();					/* 获取进程图像传送请求块Buf对象引用 */
	Buf& GetBFreeList();				/* 获取自由缓存队列控制块Buf对象引用 */

private:
	// void GetError(Buf* bp);				/* 获取I/O操作中发生的错误信息 */
	// void NotAvail(Buf* bp);				/* 从自由队列中摘下指定的缓存控制块buf */
	Buf* InCore(int blkno);	/* 检查指定字符块是否已在缓存中 */
	
private:
	Buf bFreeList;						/* 自由缓存队列控制块 */
	// Buf SwBuf;							/* 进程图像传送请求块 */
	Buf m_Buf[NBUF];					/* 缓存控制块数组 */
	unsigned char Buffer[NBUF][BUFFER_SIZE];	/* 缓冲区数组 */
	char * memdisk	;						/* 文件数据映射到内存中的首地址	*/
	// DeviceManager* m_DeviceManager;		/* 指向设备管理模块全局对象 */
};

#endif

```

Buf 控制块每一个缓存块都会对应一个缓存控制块，它会指明这个缓存块所在的 队列位置。分配和释放的操作也非常简单，分配只是简单的 从队列头取第一个缓存块，释放时将该缓存块标志位置换后放在队列尾部。

而缓存管理类则是用来管理这些缓存控制块的类，通过维护一个队列来管理这些缓存控制块

![1586138099211](E:\同济大学学习文件\大三\操作系统课设\secondFilesystem\assets\1586138099211.png)

由于本次是二级文件系统，所以不需要使用驱动程序来进行磁盘的操作，而是可以直接通过memcpy函数来操作文件映射的对应内存部分从而对磁盘文件进行操作。





##### 4.2 文件系统的设计

**超级块**

```c++
/*
 * 文件系统存储资源管理块(Super Block)的定义。
 */
class SuperBlock
{
	/* Functions */
public:
	/* Constructors */
	SuperBlock();
	/* Destructors */
	~SuperBlock();
	
	/* Members */
public:
	int		s_isize;		/* 外存Inode区占用的盘块数 */
	int		s_fsize;		/* 盘块总数 */
	
	int		s_nfree;		/* 直接管理的空闲盘块数量 */
	int		s_free[100];	/* 直接管理的空闲盘块索引表 */
	
	int		s_ninode;		/* 直接管理的空闲外存Inode数量 */
	int		s_inode[100];	/* 直接管理的空闲外存Inode索引表 */
	
	//课设中只有一个进程 不需要锁
	// int		s_flock;		/* 封锁空闲盘块索引表标志 */
	// int		s_ilock;		/* 封锁空闲Inode表标志 */
	
	int		s_fmod;			/* 内存中super block副本被修改标志，意味着需要更新外存对应的Super Block */
	int		s_ronly;		/* 本文件系统只能读出 */
	int		s_time;			/* 最近一次更新时间 */
	int		padding[47];	/* 填充使SuperBlock块大小等于1024字节，占据2个扇区 */
	//int padding[49];	//由于去掉了锁 填充加2
	char a[8];
};
```

超级快主要记录了整个磁盘的信息，如磁盘总大小，Inode区和数据区的分布，以及直接对Inode和盘块进行管理。



**内存Inode 结构**

````c++
/*
 * 内存索引节点(INode)的定义
 * 系统中每一个打开的文件、当前访问目录、
 * 挂载的子文件系统都对应唯一的内存inode。
 * 每个内存inode通过外存inode所在存储设备的设备号(i_dev)
 * 以及该设备外存inode区中的编号(i_number)来确定
 * 其对应的外存inode。
 */
class Inode
{
public:
	/* i_flag中标志位 */
	enum INodeFlag
	{
		ILOCK = 0x1,		/* 索引节点上锁 */
		IUPD  = 0x2,		/* 内存inode被修改过，需要更新相应外存inode */
		IACC  = 0x4,		/* 内存inode被访问过，需要修改最近一次访问时间 */
		IMOUNT = 0x8,		/* 内存inode用于挂载子文件系统 */
		IWANT = 0x10,		/* 有进程正在等待该内存inode被解锁，清ILOCK标志时，要唤醒这种进程 */
		ITEXT = 0x20		/* 内存inode对应进程图像的正文段 */
	};
	
	/* static const member */
	static const unsigned int IALLOC = 0x8000;		/* 文件被使用 */
	static const unsigned int IFMT = 0x6000;		/* 文件类型掩码 */
	static const unsigned int IFDIR = 0x4000;		/* 文件类型：目录文件 */
	static const unsigned int IFCHR = 0x2000;		/* 字符设备特殊类型文件 */
	static const unsigned int IFBLK = 0x6000;		/* 块设备特殊类型文件，为0表示常规数据文件 */
	static const unsigned int ILARG = 0x1000;		/* 文件长度类型：大型或巨型文件 */
	static const unsigned int ISUID = 0x800;		/* 执行时文件时将用户的有效用户ID修改为文件所有者的User ID */
	static const unsigned int ISGID = 0x400;		/* 执行时文件时将用户的有效组ID修改为文件所有者的Group ID */
	static const unsigned int ISVTX = 0x200;		/* 使用后仍然位于交换区上的正文段 */
	static const unsigned int IREAD = 0x100;		/* 对文件的读权限 */
	static const unsigned int IWRITE = 0x80;		/* 对文件的写权限 */
	static const unsigned int IEXEC = 0x40;			/* 对文件的执行权限 */
	static const unsigned int IRWXU = (IREAD|IWRITE|IEXEC);		/* 文件主对文件的读、写、执行权限 */
	static const unsigned int IRWXG = ((IRWXU) >> 3);			/* 文件主同组用户对文件的读、写、执行权限 */
	static const unsigned int IRWXO = ((IRWXU) >> 6);			/* 其他用户对文件的读、写、执行权限 */
	
	static const int BLOCK_SIZE = 512;		/* 文件逻辑块大小: 512字节 */
	static const int ADDRESS_PER_INDEX_BLOCK = BLOCK_SIZE / sizeof(int);	/* 每个间接索引表(或索引块)包含的物理盘块号 */

	static const int SMALL_FILE_BLOCK = 6;	/* 小型文件：直接索引表最多可寻址的逻辑块号 */
	static const int LARGE_FILE_BLOCK = 128 * 2 + 6;	/* 大型文件：经一次间接索引表最多可寻址的逻辑块号 */
	static const int HUGE_FILE_BLOCK = 128 * 128 * 2 + 128 * 2 + 6;	/* 巨型文件：经二次间接索引最大可寻址文件逻辑块号 */

	static const int PIPSIZ = SMALL_FILE_BLOCK * BLOCK_SIZE;

	/* static member */
	static int rablock;		/* 顺序读时，使用预读技术读入文件的下一字符块，rablock记录了下一逻辑块号
							经过bmap转换得到的物理盘块号。将rablock作为静态变量的原因：调用一次bmap的开销
							对当前块和预读块的逻辑块号进行转换，bmap返回当前块的物理盘块号，并且将预读块
							的物理盘块号保存在rablock中。 */
	
	/* Functions */
public:
	/* Constructors */
	Inode();
	/* Destructors */
	~Inode();
	
	/* 
	 * @comment 根据Inode对象中的物理磁盘块索引表，读取相应
	 * 的文件数据
	 */
	void ReadI();
	/* 
	 * @comment 根据Inode对象中的物理磁盘块索引表，将数据写入文件
	 */
	void WriteI();
	/* 
	 * @comment 将文件的逻辑块号转换成对应的物理盘块号
	 */
	int Bmap(int lbn);
	
	
	/* 
	 * @comment 更新外存Inode的最后的访问时间、修改时间
	 */
	void IUpdate();
	/* 
	 * @comment 释放Inode对应文件占用的磁盘块
	 */
	void ITrunc();



	/* 
	 * @comment 清空Inode对象中的数据
	 */
	void Clean();
	/* 
	 * @comment 将包含外存Inode字符块中信息拷贝到内存Inode中
	 */
	void ICopy(Buf* bp, int inumber);
	
	/* Members */
public:
	unsigned int i_flag;	/* 状态的标志位，定义见enum INodeFlag */
	unsigned int i_mode;	/* 文件工作方式信息 */
	
	int		i_count;		/* 引用计数 */
	int		i_nlink;		/* 文件联结计数，即该文件在目录树中不同路径名的数量 */
	
	short	i_dev;			/* 外存inode所在存储设备的设备号 */
	int		i_number;		/* 外存inode区中的编号 */
	
	short	i_uid;			/* 文件所有者的用户标识数 */
	short	i_gid;			/* 文件所有者的组标识数 */
	
	int		i_size;			/* 文件大小，字节为单位 */
	int		i_addr[10];		/* 用于文件逻辑块好和物理块好转换的基本索引表 */
	
	int		i_lastr;		/* 存放最近一次读取文件的逻辑块号，用于判断是否需要预读 */
};

````

**外存Inode结构**

```c++
/*
 * 外存索引节点(DiskINode)的定义
 * 外存Inode位于文件存储设备上的
 * 外存Inode区中。每个文件有唯一对应
 * 的外存Inode，其作用是记录了该文件
 * 对应的控制信息。
 * 外存Inode中许多字段和内存Inode中字段
 * 相对应。外存INode对象长度为64字节，
 * 每个磁盘块可以存放512/64 = 8个外存Inode
 */
class DiskInode
{
	/* Functions */
public:
	/* Constructors */
	DiskInode();
	/* Destructors */
	~DiskInode();

	/* Members */
public:
	unsigned int d_mode;	/* 状态的标志位，定义见enum INodeFlag */
	int		d_nlink;		/* 文件联结计数，即该文件在目录树中不同路径名的数量 */
	
	short	d_uid;			/* 文件所有者的用户标识数 */
	short	d_gid;			/* 文件所有者的组标识数 */
	
	int		d_size;			/* 文件大小，字节为单位 */
	int		d_addr[10];		/* 用于文件逻辑块好和物理块好转换的基本索引表 */
	
	int		d_atime;		/* 最后访问时间 */
	int		d_mtime;		/* 最后修改时间 */
};
```

UnixV6++中的Inode分为内存Inode和外存Inode，内存Inode是外存Inode的一部分副本，起到缓存的作用，可以加快Inode访问的速度。Inode 块中记录有文件存储所在的磁盘块，存储的结构如图

![1586148040920](E:\同济大学学习文件\大三\操作系统课设\secondFilesystem\assets\1586148040920.png)



**目录结构**

```c++
class DirectoryEntry
{
	/* static members */
public:
	static const int DIRSIZ = 28;	/* 目录项中路径部分的最大字符串长度 */

	/* Functions */
public:
	/* Constructors */
	DirectoryEntry();
	/* Destructors */
	~DirectoryEntry();

	/* Members */
public:
	int m_ino;		/* 目录项中Inode编号部分 */
	char m_name[DIRSIZ];	/* 目录项中路径名部分 */
};

```

整个目录结构系统 包含若干个目录文件，每个目录文件由一系列目录项组成。目录项是目录文件的基本构成单 位，每一个文件系统中存在的文件对一定对应某一个目录文件中的一条目录项。 每个目录结构的大小都是 4+28  =32，所以每个磁盘块都能装 512/32 = 16个目录项

**文件系统类**

```c++
class FileSystem
{
public:
	/* static consts */
	// static const int NMOUNT = 5;			/* 系统中用于挂载子文件系统的装配块数量 */

	// static const int SUPER_BLOCK_SECTOR_NUMBER = 200;	/* 定义SuperBlock位于磁盘上的扇区号，占据200，201两个扇区。 */
	
	static const int SUPER_BLOCK_SECTOR_NUMBER = 1;	/* 不用0号扇区，从1开始 */

	static const int ROOTINO = 0;			/* 文件系统根目录外存Inode编号 */

	// 外存inode区 3-127
	static const int INODE_NUMBER_PER_SECTOR = 8;		/* 外存INode对象长度为64字节，每个磁盘块可以存放512/64 = 8个外存Inode */
	static const int INODE_ZONE_START_SECTOR = 3;		/* 外存Inode区位于磁盘上的起始扇区号 */
	static const int INODE_ZONE_SIZE = 128-3  /*1024 - 202*/;	/* 课设为实验性质不需要这么多Inode */	/* 磁盘上外存Inode区占据的扇区数 */

	// 外存数据区 128-1023
	static const int DATA_ZONE_START_SECTOR = 128;/*1024*/		/* 数据区的起始扇区号 */
	static const int DATA_ZONE_END_SECTOR = 1024 - 1/* 18000 - 1 */;	/* 数据区的结束扇区号 */
	static const int DATA_ZONE_SIZE = 1024 - DATA_ZONE_START_SECTOR;	/* 数据区占据的扇区数量 */

	/* Functions */
public:
	/* Constructors */
	FileSystem();
	/* Destructors */
	~FileSystem();

	/* 
	 * @comment 初始化成员变量
	 */
	void Initialize();

	/* 
	* @comment 系统初始化时读入SuperBlock
	*/
	void LoadSuperBlock();

	/* 
	 * @comment 由于只有一个设备，不需要设备号
	 * 该文件系统的SuperBlock
	 */
	SuperBlock* GetFS();


	/* 
	 * @comment 将SuperBlock对象的内存副本更新到
	 * 存储设备的SuperBlock中去
	 */
	void Update();

	/* 
	 * @comment  在存储设备上分配一个空闲
	 * 外存INode，一般用于创建新的文件。
	 */
	Inode* IAlloc();


	/* 
	 * @comment  释放编号为number
	 * 的外存INode，一般用于删除文件。
	 */
	void IFree(int number);

	/* 
	 * @comment 在存储设备上分配空闲磁盘块
	 */
	Buf* Alloc();

	
	/* 
	 * @comment 释放存储设备上编号为blkno的磁盘块
	 */
	void Free(int blkno);

	/* 
	 * @comment 查找文件系统装配表，搜索指定Inode对应的Mount装配块
	 */
	// Mount* GetMount(Inode* pInode);

private:
	/* 
	 * @comment 检查设备dev上编号blkno的磁盘块是否属于
	 * 数据盘块区
	 */
	bool BadBlock(SuperBlock* spb, int blkno);

	/* Members */
public:
	// Mount m_Mount[NMOUNT];		/* 文件系统装配块表，Mount[0]用于根文件系统 */

private:
	BufferManager* m_BufferManager;		/* FileSystem类需要缓存管理模块(BufferManager)提供的接口 */
	// int updlock;				/* Update()函数的锁，该函数用于同步内存各个SuperBlock副本以及，
	// 							被修改过的内存Inode。任一时刻只允许一个进程调用该函数 */
};
```

可以看到，文件系统类是对于上面各个模块的一个整合，提供了操作超级块，外存Inode块，以及Buffer的方法，实现了对于文件系统的底层控制功能。

##### 4.3 高层API的设计

**打开文件结构**

```c++
/*
 * 打开文件控制块File类。
 * 该结构记录了进程打开文件
 * 的读、写请求类型，文件读写位置等等。
 */
class File
{
public:
	/* Enumerate */
	enum FileFlags
	{
		FREAD = 0x1,			/* 读请求类型 */
		FWRITE = 0x2,			/* 写请求类型 */
		FPIPE = 0x4				/* 管道类型 */
	};
	
	/* Functions */
public:
	/* Constructors */
	File();
	/* Destructors */
	~File();

	
	/* Member */
	unsigned int f_flag;		/* 对打开文件的读、写操作要求 */
	int		f_count;			/* 当前引用该文件控制块的进程数量 */
	Inode*	f_inode;			/* 指向打开文件的内存Inode指针 */
	int		f_offset;			/* 文件读写位置指针 */
};


/*
 * 进程打开文件描述符表(OpenFiles)的定义
 * 进程的u结构中包含OpenFiles类的一个对象，
 * 维护了当前进程的所有打开文件。
 */
class OpenFiles
{
	/* static members */
public:
	static const int NOFILES = 15;	/* 进程允许打开的最大文件数 */
	
	/* Functions */
public:
	/* Constructors */
	OpenFiles();
	/* Destructors */
	~OpenFiles();
	
	/* 
	 * @comment 进程请求打开文件时，在打开文件描述符表中分配一个空闲表项
	 */
	int AllocFreeSlot();
	
	/* 
	 * @comment Dup系统调用时复制打开文件描述符表中的描述符
	 */
	int	Clone(int fd);
	
	/* 
	 * @comment 根据用户系统调用提供的文件描述符参数fd，
	 * 找到对应的打开文件控制块File结构
	 */
	File* GetF(int fd);
	/* 
	 * @comment 为已分配到的空闲描述符fd和已分配的打开文件表中
	 * 空闲File对象建立勾连关系
	 */
	void SetF(int fd, File* pFile);
	
	/* Members */
private:
	File *ProcessOpenFileTable[NOFILES];		/* File对象的指针数组，指向系统打开文件表中的File对象 */
};

/*
 * 文件I/O的参数类
 * 对文件读、写时需用到的读、写偏移量、
 * 字节数以及目标区域首地址参数。
 */
class IOParameter
{
	/* Functions */
public:
	/* Constructors */
	IOParameter();
	/* Destructors */
	~IOParameter();
	
	/* Members */
public:
	unsigned char* m_Base;	/* 当前读、写用户目标区域的首地址 */
	int m_Offset;	/* 当前读、写文件的字节偏移量 */
	int m_Count;	/* 当前还剩余的读、写字节数量 */
};
```

打开文件控制块主要用于记录打开文件的信息，而打开文件描述符表主要用于记录进程打开的文件，最后的IOparameter类是一个辅助的类，主要用于文件读写过程中记录读写参数的工作。



**打开文件管理类**

```c++
/* 
 * 打开文件管理类(OpenFileManager)负责
 * 内核中对打开文件机构的管理，为进程
 * 打开文件建立内核数据结构之间的勾连
 * 关系。
 * 勾连关系指进程u区中打开文件描述符指向
 * 打开文件表中的File打开文件控制结构，
 * 以及从File结构指向文件对应的内存Inode。
 */
class OpenFileTable
{
public:
	/* static consts */
	//static const int NINODE	= 100;	/* 内存Inode的数量 */
	static const int NFILE	= 100;	/* 打开文件控制块File结构的数量 */

	/* Functions */
public:
	/* Constructors */
	OpenFileTable();
	/* Destructors */
	~OpenFileTable();
	
	// /* 
	 // * @comment 根据用户系统调用提供的文件描述符参数fd，
	 // * 找到对应的打开文件控制块File结构
	 // */
	// File* GetF(int fd);
	/* 
	 * @comment 在系统打开文件表中分配一个空闲的File结构
	 */
	File* FAlloc();
	/* 
	 * @comment 对打开文件控制块File结构的引用计数f_count减1，
	 * 若引用计数f_count为0，则释放File结构。
	 */
	void CloseF(File* pFile);
	
	/* Members */
public:
	File m_File[NFILE];			/* 系统打开文件表，为所有进程共享，进程打开文件描述符表
								中包含指向打开文件表中对应File结构的指针。*/
};


```

打开文件管理类中主要记录整个系统中打开的文件，为所有进程所共享。负责内核中对打开文件机构的管理，为进程打开文件建立内核数据结构之间的勾 连关系。 勾连关系指进程u区中打开文件描述符指向打开文件表中的File打开文件控制结 构，以及从File结构指向文件对应的内存Inode。 



**内存Inode表**

```c++
/* 
 * 内存Inode表(class InodeTable)
 * 负责内存Inode的分配和释放。
 */
class InodeTable
{
	/* static consts */
public:
	static const int NINODE	= 100;	/* 内存Inode的数量 */
	
	/* Functions */
public:
	/* Constructors */
	InodeTable();
	/* Destructors */
	~InodeTable();
	
	/* 
	 * @comment 初始化对g_FileSystem对象的引用
	 */
	void Initialize();
	/* 
	 * @comment 根据指定设备号dev，外存Inode编号获取对应
	 * Inode。如果该Inode已经在内存中，对其上锁并返回该内存Inode，
	 * 如果不在内存中，则将其读入内存后上锁并返回该内存Inode
	 */
	Inode* IGet(int inumber);
	/* 
	 * @comment 减少该内存Inode的引用计数，如果此Inode已经没有目录项指向它，
	 * 且无进程引用该Inode，则释放此文件占用的磁盘块。
	 */
	void IPut(Inode* pNode);

	/* 
	 * @comment 将所有被修改过的内存Inode更新到对应外存Inode中
	 */
	void UpdateInodeTable();
	
	/* 
	 * @comment 检查设备dev上编号为inumber的外存inode是否有内存拷贝，
	 * 如果有则返回该内存Inode在内存Inode表中的索引
	 */
	int IsLoaded(int inumber);
	/* 
	 * @comment 在内存Inode表中寻找一个空闲的内存Inode
	 */
	Inode* GetFreeInode();
	
	/* Members */
public:
	Inode m_Inode[NINODE];		/* 内存Inode数组，每个打开文件都会占用一个内存Inode */

	FileSystem* m_FileSystem;	/* 对全局对象g_FileSystem的引用 */
};
```

内存Inode表主要用于管理内存中的所有Inode，通常是和打开文件管理类共同使用的，它将会负责所有内存 Inode 的分配和释放。一组连续的内存 Inode 构成了一张 内存文件索引节点表，当打开某一文件时，如果找不到其相应的内存 Inode，就在该表中分 配一个空闲项，并将该文件的外存 inode 中的主要部分拷贝进去，然后填写相应的外存 DiskInode 的地址信息。当关闭文件时，如果相应的内存 Inode 已经没有其他用处，则被放 弃以便移作他用，同时在释放前如果发现其被置为已修改标志，需要将其更新到 DiskInode 上。



**文件管理类**

```c++
/* 
 * 文件管理类(FileManager)
 * 封装了文件系统的各种系统调用在核心态下处理过程，
 * 如对文件的Open()、Close()、Read()、Write()等等
 * 封装了对文件系统访问的具体细节。
 */
class FileManager
{
public:
	/* 目录搜索模式，用于NameI()函数 */
	enum DirectorySearchMode
	{
		OPEN = 0,		/* 以打开文件方式搜索目录 */
		CREATE = 1,		/* 以新建文件方式搜索目录 */
		DELETE = 2		/* 以删除文件方式搜索目录 */
	};

	/* Functions */
public:
	/* Constructors */
	FileManager();
	/* Destructors */
	~FileManager();


	/* 
	 * @comment 初始化对全局对象的引用
	 */
	void Initialize();

	/* 
	 * @comment Open()系统调用处理过程
	 */
	void Open();

	/* 
	 * @comment Creat()系统调用处理过程
	 */
	void Creat();

	/* 
	 * @comment Open()、Creat()系统调用的公共部分
	 */
	void Open1(Inode* pInode, int mode, int trf);

	/* 
	 * @comment Close()系统调用处理过程
	 */
	void Close();

	/* 
	 * @comment Seek()系统调用处理过程
	 */
	void Seek();

	/* 
	 * @comment Dup()复制进程打开文件描述符
	 */
	// void Dup();

	/* 
	 * @comment FStat()获取文件信息
	 */
	void FStat();

	/* 
	 * @comment FStat()获取文件信息
	 */
	void Stat();

	/* FStat()和Stat()系统调用的共享例程 */
	void Stat1(Inode* pInode, unsigned long statBuf);

	/* 
	 * @comment Read()系统调用处理过程
	 */
	void Read();

	/* 
	 * @comment Write()系统调用处理过程
	 */
	void Write();

	/* 
	 * @comment 读写系统调用公共部分代码
	 */
	void Rdwr(enum File::FileFlags mode);


	/* 
	 * @comment 目录搜索，将路径转化为相应的Inode，
	 * 返回上锁后的Inode
	 */
	Inode* NameI(char (*func)(), enum DirectorySearchMode mode);

	/* 
	 * @comment 获取路径中的下一个字符
	 */
	static char NextChar();

	/* 
	 * @comment 被Creat()系统调用使用，用于为创建新文件分配内核资源
	 */
	Inode* MakNode(unsigned int mode);

	/* 
	 * @comment 向父目录的目录文件写入一个目录项
	 */
	void WriteDir(Inode* pInode);

	/*
	 * @comment 设置当前工作路径
	 */
	void SetCurDir(char* pathname);

	/* 
	 * @comment 检查对文件或目录的搜索、访问权限，作为系统调用的辅助函数
	 */
	int Access(Inode* pInode, unsigned int mode);

	/* 
	 * @comment 检查文件是否属于当前用户
	 */
	Inode* Owner();


	/* 改变当前工作目录 */
	void ChDir();



	/* 取消文件 */
	void UnLink();

	/* 用于建立特殊设备文件的系统调用 */
	void MkNod();
	
public:
	/* 引用全局 super block */
	SuperBlock *m_spb;
	/* 根目录内存Inode */
	Inode* rootDirInode;

	/* 对全局对象g_FileSystem的引用，该对象负责管理文件系统存储资源 */
	FileSystem* m_FileSystem;
	
	/* 对全局对象g_InodeTable的引用，该对象负责内存Inode表的管理 */
	InodeTable* m_InodeTable;

	/* 对全局对象g_OpenFileTable的引用，该对象负责打开文件表项的管理 */
	OpenFileTable* m_OpenFileTable;
};
```

文件管理类是对之前所有资源的最高级的整合，我们大部分的系统调用API都是通过文件管理类中实现的高级方法所实现的。



### 六、API的实现

我们设计以上数据结构的目的主要是为了下面的高级API的实现，从而使得我们的用户能够简单的使用我们的二级文件系统。

##### 6.1 fcreate

